"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[5042],{3119:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=a(5893),n=a(1151);const o={title:"Rationale, or Why Create Another Mapper?"},i=void 0,s={id:"mapper/rationale",title:"Rationale, or Why Create Another Mapper?",description:"We developed a project that during its planning phase we determined that it",source:"@site/docs/mapper/22-rationale.md",sourceDirName:"mapper",slug:"/mapper/rationale",permalink:"/mapper/rationale",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/22-rationale.md",tags:[],version:"current",sidebarPosition:22,frontMatter:{title:"Rationale, or Why Create Another Mapper?"},sidebar:"docs",previous:{title:"Debugging the Mapper",permalink:"/mapper/debugging"},next:{title:"rekalogika/psr-16-simple-cache-bundle",permalink:"/psr-16-simple-cache-bundle/"}},p={},l=[];function d(e){const t={a:"a",code:"code",p:"p",...(0,n.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"We developed a project that during its planning phase we determined that it\nwould be beneficial to integrate an automapper into the architecture. We looked\naround and found some potential automappers, and decided to go ahead with the\nplanned architecture."}),"\n",(0,r.jsxs)(t.p,{children:["We first tried\n",(0,r.jsx)(t.a,{href:"https://github.com/mark-gerarts/automapper-plus",children:"AutoMapper-Plus"})," and\nimmediately ran into the issue that it reads and writes directly to properties,\nincluding private properties, which is unacceptable to our purposes. For\nexample, we store monetary values as integers in the object, and convert them\nfrom and to ",(0,r.jsx)(t.code,{children:"Money"})," objects in the getter and setter. Using this mapper, it\nwould get the raw integers, not the ",(0,r.jsx)(t.code,{children:"Money"})," objects. We also feel it violates\nthe principles of encapsulation. However, this was not a blocker as it supports\na custom property accessor, and it was possible to resolve this issue by\ncreating an adapter that uses Symfony PropertyAccess component."]}),"\n",(0,r.jsx)(t.p,{children:"With AutoMapper-Plus, users are expected to create a mapping configuration for\neach mapping pair. It has an automatic creation of mappings for simple mapping.\nAll of our entities and DTOs are typed, but we need to create a mapping for\nevery non-trivial pair, despite the type information is already there in the\ninvolved classes. Custom mapper is available, but it does not let us access the\nmain mapper. If a mapping pair uses a custom mapper, we are responsible for\nmapping everything, including nested objects, because the option to delegate to\nthe main mapper is not available. There was another case that was simply not\npossible to accomplish, I don't remember what it was, but it forced us to switch\nto another mapper overnight."}),"\n",(0,r.jsxs)(t.p,{children:["Our next mapper was ",(0,r.jsx)(t.a,{href:"https://github.com/jolicode/automapper",children:"Jolicode\nAutomapper"}),", formerly known as ",(0,r.jsx)(t.a,{href:"https://github.com/janephp/automapper",children:"Jane\nAutomapper"}),". It behaved as expected,\nthere were no big surprises, and there was very little to complain about its\nbehavior. It is very fast as it compiles its mapping code to PHP files. The\nproblem was error handling. When an error occurred in the compiled mappers, it\nwas usually a ",(0,r.jsx)(t.code,{children:"TypeError"}),". It was difficult to debug, and even more difficult to\nresolve the problem. Addressing the problem requires the skill of working with\nAST. We found that the problems were usually deployment errors (usually\nforgetting to clear the cache), some edge cases (easy to work around), or bugs\nin the mapper. It was rare to get an error, but when it happened, it was\ndifficult and time-consuming to resolve. We did contribute some fixes back to\nthe project."]}),"\n",(0,r.jsx)(t.p,{children:"The second problem was that the mapper was difficult to extend. Adding a new\ntransformer requires the knowledge of working with AST, and there was no option\nto do a mapping using plain old PHP code that you write yourself. We hit a brick\nwall when a new requirement surfaced that requires the mapper to target an\nabstract class, a feature that was not supported by the mapper. We figured it\nwould be easier for us to spend a week creating our own mapper from scratch\nusing our experiences with the other mappers, and here we are."}),"\n",(0,r.jsx)(t.p,{children:"Other mappers that were considered:"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://github.com/SymfonyCasts/micro-mapper/",children:"MicroMapper"})," is a mapper that\nrequires you to write the mapping code yourself. It is all manual work, but\nstill working within the mapping framework, and should be suitable for our\npurpose, as long as we are willing to write the mapping code ourselves. The\nmapping code also supports delegating to the main mapper, unlike\nAutoMapper-Plus. However, at this point, we were way past of contemplating\nwhether to do it manually, so we did not consider it further."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://github.com/symfony/symfony/pull/51741",children:"Pull request for a future Symfony Mapper"}),".\nIn the form that I saw it, it was too simplistic, and does not provide any\nextension points. I (@priyadi) did provide some feedback in the pull request."]})]})}function c(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,t,a)=>{a.d(t,{Z:()=>s,a:()=>i});var r=a(7294);const n={},o=r.createContext(n);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);