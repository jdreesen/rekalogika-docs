"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[4578],{4777:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var t=r(5893),a=r(1151);const o={title:"Creating a Custom Transformer"},i=void 0,s={id:"mapper/creating-transformer",title:"Creating a Custom Transformer",description:"Extend the mapper by creating your own transformer.",source:"@site/docs/mapper/12-creating-transformer.md",sourceDirName:"mapper",slug:"/mapper/creating-transformer",permalink:"/mapper/creating-transformer",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/12-creating-transformer.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{title:"Creating a Custom Transformer"},sidebar:"docs",previous:{title:"Architecture",permalink:"/mapper/architecture"},next:{title:"Manual Mapping using a Class Method",permalink:"/mapper/method-mapper"}},c={},p=[{value:"Creating the Transformer",id:"creating-the-transformer",level:2},{value:"Registering the Transformer",id:"registering-the-transformer",level:2},{value:"Verifying",id:"verifying",level:2},{value:"Delegating Mapping to the Main Transformer",id:"delegating-mapping-to-the-main-transformer",level:2},{value:"Caching and Circular References Detection",id:"caching-and-circular-references-detection",level:2}];function l(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Extend the mapper by creating your own transformer."}),"\n",(0,t.jsx)(n.h2,{id:"creating-the-transformer",children:"Creating the Transformer"}),"\n",(0,t.jsxs)(n.p,{children:["Suppose you are using the ",(0,t.jsx)(n.code,{children:"brick/money"})," library to represent money in your\napplication, and you need to map the ",(0,t.jsx)(n.code,{children:"Money"})," object to the following DTO:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",metastring:'title="src/Dto/MoneyDto.php"',children:"namespace App\\Dto;\n\nclass MoneyDto\n{\n    public function __construct(\n        private string $amount,\n        private string $currency,\n    ) {\n    }\n\n    public function getAmount(): string\n    {\n        return $this->amount;\n    }\n\n    public function getCurrency(): string\n    {\n        return $this->currency;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can create the transformer as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",metastring:'title="src/Mapper/MoneyToMoneyDtoTransformer.php"',children:"namespace App\\Mapper;\n\nuse Brick\\Money\\Money;\nuse Rekalogika\\Mapper\\Context\\Context;\nuse Rekalogika\\Mapper\\Contracts\\TransformerInterface;\nuse Rekalogika\\Mapper\\Contracts\\TypeMapping;\nuse Rekalogika\\Mapper\\Exception\\InvalidArgumentException;\nuse Rekalogika\\Mapper\\Tests\\Fixtures\\Money\\MoneyDto;\nuse Rekalogika\\Mapper\\Util\\TypeCheck;\nuse Rekalogika\\Mapper\\Util\\TypeFactory;\nuse Symfony\\Component\\PropertyInfo\\Type;\n\nclass MoneyToMoneyDtoTransformer implements TransformerInterface\n{\n    // This tells the library that this transformer supports the transformation\n    // from the Money object to the MoneyDto object, and vice versa.\n    //\n    // The TypeFactory methods are convenience methods for creating the\n    // PropertyInfo Type objects.\n\n    public function getSupportedTransformation(): iterable\n    {\n\n        yield new TypeMapping(\n            TypeFactory::objectOfClass(Money::class),\n            TypeFactory::objectOfClass(MoneyDto::class)\n        );\n\n        yield new TypeMapping(\n            TypeFactory::objectOfClass(MoneyDto::class),\n            TypeFactory::objectOfClass(Money::class)\n        );\n    }\n\n    // This method is called when the mapper is trying to transform Money to\n    // MoneyDto, and vice versa.\n    //\n    // The $source and $target parameters are the source and target objects,\n    // respectively. $target is usually null, unless there is already an\n    // existing value in the target object.\n    //\n    // $sourceType and $targetType are the types of the source and target, in\n    // the form of PropertyInfo Type object.\n    //\n    // The TypeCheck class is a convenience class for verifying the type\n    // specified by a Type object.\n\n    public function transform(\n        mixed $source,\n        mixed $target,\n        ?Type $sourceType,\n        ?Type $targetType,\n        Context $context\n    ): mixed {\n        if (\n            $source instanceof Money\n            && TypeCheck::isObjectOfType($targetType, MoneyDto::class)\n        ) {\n            return new MoneyDto(\n                amount: $source->getAmount()->__toString(),\n                currency: $source->getCurrency()->getCurrencyCode(),\n            );\n        }\n\n        if (\n            $source instanceof MoneyDto\n            && TypeCheck::isObjectOfType($targetType, Money::class)\n        ) {\n            return Money::of(\n                $source->getAmount(),\n                $source->getCurrency()\n            );\n        }\n\n        throw new InvalidArgumentException('Unsupported transformation');\n    }\n}\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"registering-the-transformer",children:"Registering the Transformer"}),"\n",(0,t.jsxs)(n.p,{children:["If you are not using autoconfiguration, you need to register the transformer\nand add the ",(0,t.jsx)(n.code,{children:"rekalogika.mapper.transformer"})," tag:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="config/services.yaml"',children:"services:\n    App\\Mapper\\MoneyToMoneyDtoTransformer:\n        tags:\n            - { name: rekalogika.mapper.transformer, priority: 0 }\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The default priority is ",(0,t.jsx)(n.code,{children:"0"}),". The higher the priority, the mapping provided by\nthe transformer will be taken into consideration earlier."]})}),"\n",(0,t.jsxs)(n.p,{children:["If you are using autoconfiguration, you can use the ",(0,t.jsx)(n.code,{children:"#[AsTaggedItem]"})," attribute\nto set its property."]}),"\n",(0,t.jsx)(n.h2,{id:"verifying",children:"Verifying"}),"\n",(0,t.jsxs)(n.p,{children:["To verify that the transformer is registered, you can use the ",(0,t.jsx)(n.code,{children:"debug:container"}),"\ncommand:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"php bin/console debug:container --tag=rekalogika.mapper.transformer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Also, you can verify the existense of the transformer in the mapping table:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"php bin/console rekalogika:mapper:mapping\n"})}),"\n",(0,t.jsx)(n.h2,{id:"delegating-mapping-to-the-main-transformer",children:"Delegating Mapping to the Main Transformer"}),"\n",(0,t.jsxs)(n.p,{children:["Your transformer does not need to do everything. You can delegate the mapping of\nproperties or other objects back to the main transformer. To accomplish this,\nyour transformer needs to implement ",(0,t.jsx)(n.code,{children:"MainTransformerAwareInterface"}),", and we\nalso provide a ",(0,t.jsx)(n.code,{children:"MainTransformerAwareTrait"})," to help you with that:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",metastring:'title="src/Mapper/MyObjectToMyDtoTransformer.php"',children:"namespace App\\Mapper;\n\nuse Rekalogika\\Mapper\\Context\\Context;\nuse Rekalogika\\Mapper\\Contracts\\MainTransformerAwareInterface;\nuse Rekalogika\\Mapper\\Contracts\\MainTransformerInterface;\nuse Rekalogika\\Mapper\\Contracts\\TransformerInterface;\nuse Symfony\\Component\\PropertyInfo\\PropertyTypeExtractorInterface;\n\nclass MyObjectToMyDtoTransformer implements\n    TransformerInterface,\n    // highlight-next-line\n    MainTransformerAwareInterface\n{\n    // highlight-next-line\n    use MainTransformerAwareTrait;\n\n    public function __construct(\n        // highlight-start\n        // need this to identify target property types\n        private PropertyTypeExtractorInterface $propertyTypeExtractor,\n        // highlight-end\n    ){\n    }\n\n    public function transform(\n        mixed $source,\n        mixed $target,\n        ?Type $sourceType,\n        ?Type $targetType,\n        Context $context\n    ): mixed {\n        // ...\n\n        // highlight-start\n        // identify the target property types\n        $targetPropertyTypes = $this->propertyTypeExtractor\n            ->getTypes($target, 'someProperty');\n\n        // the delegation to the main transformer\n        $result = $this->getMainTransformer()->transform(\n            source: $source->getSomeProperty(),\n            target: null, // unless there is already an existing value in\n                          // the target object\n            targetTypes: $targetPropertyTypes,\n            context: $context\n        );\n\n        // saves the result to the target object\n        $target->someProperty = $result;\n        // highlight-end\n\n        // ...\n\n        return $target;\n    }\n\n    // ...\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"caching-and-circular-references-detection",children:"Caching and Circular References Detection"})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>s,a:()=>i});var t=r(7294);const a={},o=t.createContext(a);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);