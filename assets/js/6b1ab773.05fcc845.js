"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4205],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(n),u=i,m=d["".concat(c,".").concat(u)]||d[u]||h[u]||r;return n?o.createElement(m,a(a({ref:t},p),{},{components:n})):o.createElement(m,a({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[d]="string"==typeof e?e:i,a[1]=l;for(var s=2;s<r;s++)a[s]=n[s];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var o=n(7462),i=(n(7294),n(3905));const r={title:"Lazy Chained Matching"},a=void 0,l={unversionedId:"doctrine-collections-decorator/cookbook/lazy-chained-matching",id:"doctrine-collections-decorator/cookbook/lazy-chained-matching",title:"Lazy Chained Matching",description:"If you call matching() on a PersistentCollection, it will immediately query",source:"@site/docs/doctrine-collections-decorator/cookbook/16-lazy-chained-matching.md",sourceDirName:"doctrine-collections-decorator/cookbook",slug:"/doctrine-collections-decorator/cookbook/lazy-chained-matching",permalink:"/doctrine-collections-decorator/cookbook/lazy-chained-matching",draft:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/doctrine-collections-decorator/cookbook/16-lazy-chained-matching.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{title:"Lazy Chained Matching"},sidebar:"docs",previous:{title:"Loading Prevention in Extra Lazy Collections",permalink:"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention"},next:{title:"rekalogika/domain-event",permalink:"/domain-event/"}},c={},s=[{value:"The Decorator Class",id:"the-decorator-class",level:2},{value:"Usage Example in Entities",id:"usage-example-in-entities",level:2},{value:"The Caller Side",id:"the-caller-side",level:2}],p={toc:s},d="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If you call ",(0,i.kt)("inlineCode",{parentName:"p"},"matching()")," on a ",(0,i.kt)("inlineCode",{parentName:"p"},"PersistentCollection"),", it will immediately query\nthe database and return the result, even if you won't use the result. If you\ncall ",(0,i.kt)("inlineCode",{parentName:"p"},"matching()")," again on the result, it will be processed from the in-memory\n",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayCollection"),", not from the database."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"With ",(0,i.kt)("inlineCode",{parentName:"p"},"EXTRA_LAZY")," fetch mode, ",(0,i.kt)("inlineCode",{parentName:"p"},"PersistentCollection")," will return a\n",(0,i.kt)("inlineCode",{parentName:"p"},"LazyCriteriaCollection"),". But subsequent ",(0,i.kt)("inlineCode",{parentName:"p"},"matching()")," call on the result\nwill still be processed immediately.")),(0,i.kt)("p",null,"We can decorate the collection so that chained-",(0,i.kt)("inlineCode",{parentName:"p"},"matching()")," will be done lazily.\nThe database query will only be done when the caller asks for the result.\nCalling ",(0,i.kt)("inlineCode",{parentName:"p"},"matching()")," will only merge the supplied criteria to the existing\ncriteria."),(0,i.kt)("p",null,"With the standard behavior, the following code will do the processing three\ntimes (twice with ",(0,i.kt)("inlineCode",{parentName:"p"},"EXTRA_LAZY"),"). With our decorator, it will only be done once\nwhen ",(0,i.kt)("inlineCode",{parentName:"p"},"foreach")," is called."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"/** @var Collection<array-key,mixed> $collection */\n/** @var Criteria $criteria1 */\n/** @var Criteria $criteria2 */\n/** @var Criteria $criteria3 */\n\n$result = $collection\n    ->matching($criteria1)\n    ->matching($criteria2)\n    ->matching($criteria3);\n\nforeach ($result as $item) {\n    // ...\n} \n")),(0,i.kt)("h2",{id:"the-decorator-class"},"The Decorator Class"),(0,i.kt)("p",null,"This package already comes with ",(0,i.kt)("inlineCode",{parentName:"p"},"LazyMatchingCollection")," that you can use for\nthis purpose."),(0,i.kt)("h2",{id:"usage-example-in-entities"},"Usage Example in Entities"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Doctrine\\Common\\Collections\\Collection;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Rekalogika\\Collections\\Decorator\\LazyMatching\\LazyMatchingCollection;\n\n#[ORM\\Entity()]\nclass BookShelf\n{\n    #[ORM\\OneToMany(targetEntity: Book::class, fetch: 'EXTRA_LAZY', indexBy: 'id')]\n    private Collection $books;\n\n    public function __construct()\n    {\n        $this->books = new ArrayCollection();\n    }\n\n    /**\n     * @return Collection<array-key,Book>&Selectable<array-key,Book>\n     */\n    public function getBooks(): Collection&Selectable\n    {\n        // highlight-next-line\n        return new LazyMatchingCollection($this->books);\n    }\n\n    public function getScienceBooks(): Collection\n    {\n        return $this->getBooks()->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->eq('genre', 'science'))\n        );\n    }\n\n    public function getOldScienceBooks(): Collection\n    {\n        return $this->getScienceBook()->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->lt('publishedAt', new \\DateTime('-10 years')))\n        );\n    }\n}\n")),(0,i.kt)("h2",{id:"the-caller-side"},"The Caller Side"),(0,i.kt)("p",null,"Then the caller will be able to do something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$bookShelf = $entityManager->find(BookShelf::class, 1);\n\n$oldScienceBook = $bookShelf->getOldScienceBook();\n\nforeach ($oldScienceBook as $book) {\n    echo $book->getTitle();\n}\n")),(0,i.kt)("p",null,"With this example, there will be only two database queries, one due to\n",(0,i.kt)("inlineCode",{parentName:"p"},"$entityManager->find()"),", and one due to the ",(0,i.kt)("inlineCode",{parentName:"p"},"foreach")," call."))}h.isMDXComponent=!0}}]);