"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[9356],{8035:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var t=r(5893),o=r(1151);const a={title:"Creating a Custom Transformer"},s=void 0,i={id:"mapper/creating-transformer",title:"Creating a Custom Transformer",description:"This chapter describes how to create a custom transformer.",source:"@site/docs/mapper/03-creating-transformer.md",sourceDirName:"mapper",slug:"/mapper/creating-transformer",permalink:"/mapper/creating-transformer",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/03-creating-transformer.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Creating a Custom Transformer"},sidebar:"docs",previous:{title:"Architecture",permalink:"/mapper/architecture"},next:{title:"Manual Mapping using a Class Method",permalink:"/mapper/method-mapper"}},c={},p=[{value:"Creating the Transformer",id:"creating-the-transformer",level:2},{value:"Registering the Transformer",id:"registering-the-transformer",level:2},{value:"Verifying",id:"verifying",level:2}];function l(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This chapter describes how to create a custom transformer."}),"\n",(0,t.jsx)(n.h2,{id:"creating-the-transformer",children:"Creating the Transformer"}),"\n",(0,t.jsxs)(n.p,{children:["Suppose you are using the ",(0,t.jsx)(n.code,{children:"brick/money"})," library to represent money in your\napplication, and you need to map the ",(0,t.jsx)(n.code,{children:"Money"})," object to the following DTO:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",metastring:'title="src/Dto/MoneyDto.php"',children:"namespace App\\Dto;\n\nclass MoneyDto\n{\n    public function __construct(\n        private string $amount,\n        private string $currency,\n    ) {\n    }\n\n    public function getAmount(): string\n    {\n        return $this->amount;\n    }\n\n    public function getCurrency(): string\n    {\n        return $this->currency;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can create the transformer as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",metastring:'title="src/Mapper/MoneyToMoneyDtoTransformer.php"',children:"namespace App\\Mapper;\n\nuse Brick\\Money\\Money;\nuse Rekalogika\\Mapper\\Contracts\\TransformerInterface;\nuse Rekalogika\\Mapper\\Contracts\\TypeMapping;\nuse Rekalogika\\Mapper\\Exception\\InvalidArgumentException;\nuse Rekalogika\\Mapper\\Tests\\Fixtures\\Money\\MoneyDto;\nuse Rekalogika\\Mapper\\Util\\TypeCheck;\nuse Rekalogika\\Mapper\\Util\\TypeFactory;\nuse Symfony\\Component\\PropertyInfo\\Type;\n\nclass MoneyToMoneyDtoTransformer implements TransformerInterface\n{\n    // This tells the library that this transformer supports the transformation\n    // from the Money object to the MoneyDto object, and vice versa.\n    //\n    // The TypeFactory methods are convenience methods for creating the\n    // PropertyInfo Type objects.\n\n    public function getSupportedTransformation(): iterable\n    {\n\n        yield new TypeMapping(\n            TypeFactory::objectOfClass(Money::class),\n            TypeFactory::objectOfClass(MoneyDto::class)\n        );\n\n        yield new TypeMapping(\n            TypeFactory::objectOfClass(MoneyDto::class),\n            TypeFactory::objectOfClass(Money::class)\n        );\n    }\n\n    // This method is called when the mapper is trying to transform Money to\n    // MoneyDto, and vice versa.\n    //\n    // The $source and $target parameters are the source and target objects,\n    // respectively. $target is usually null, unless there is already an\n    // existing value in the target object.\n    //\n    // $sourceType and $targetType are the types of the source and target, in\n    // the form of PropertyInfo Type object.\n    //\n    // The TypeCheck class is a convenience class for verifying the type\n    // specified by a Type object.\n\n    public function transform(\n        mixed $source,\n        mixed $target,\n        Type $sourceType,\n        ?Type $targetType,\n        array $context\n    ): mixed {\n        if (\n            $source instanceof Money\n            && TypeCheck::isObjectOfType($targetType, MoneyDto::class)\n        ) {\n            return new MoneyDto(\n                amount: $source->getAmount()->__toString(),\n                currency: $source->getCurrency()->getCurrencyCode(),\n            );\n        }\n\n        if (\n            $source instanceof MoneyDto\n            && TypeCheck::isObjectOfType($targetType, Money::class)\n        ) {\n            return Money::of(\n                $source->getAmount(),\n                $source->getCurrency()\n            );\n        }\n\n        throw new InvalidArgumentException('Unsupported transformation');\n    }\n}\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"registering-the-transformer",children:"Registering the Transformer"}),"\n",(0,t.jsxs)(n.p,{children:["If you are not using autoconfiguration, you need to register the transformer\nand add the ",(0,t.jsx)(n.code,{children:"rekalogika.mapper.transformer"})," tag:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="config/services.yaml"',children:"services:\n    App\\Mapper\\MoneyToMoneyDtoTransformer:\n        tags:\n            - { name: rekalogika.mapper.transformer, priority: 0 }\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The default priority is ",(0,t.jsx)(n.code,{children:"0"}),". The higher the priority, the mapping provided by\nthe transformer will be taken into consideration earlier."]})}),"\n",(0,t.jsxs)(n.p,{children:["If you are using autoconfiguration, you can use the ",(0,t.jsx)(n.code,{children:"#[AsTaggedItem]"})," attribute\nto set its property."]}),"\n",(0,t.jsx)(n.h2,{id:"verifying",children:"Verifying"}),"\n",(0,t.jsxs)(n.p,{children:["To verify that the transformer is registered, you can use the ",(0,t.jsx)(n.code,{children:"debug:container"}),"\ncommand:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"php bin/console debug:container --tag=rekalogika.mapper.transformer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Also, you can verify the existense of the transformer in the mapping table:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"php bin/console rekalogika:mapper:mapping\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>i,a:()=>s});var t=r(7294);const o={},a=t.createContext(o);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);