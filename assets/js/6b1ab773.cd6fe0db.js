"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4205],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(n),u=a,m=p["".concat(c,".").concat(u)]||p[u]||h[u]||i;return n?o.createElement(m,r(r({ref:t},d),{},{components:n})):o.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:a,r[1]=l;for(var s=2;s<i;s++)r[s]=n[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var o=n(7462),a=(n(7294),n(3905));const i={title:"Lazy Chained Matching"},r=void 0,l={unversionedId:"doctrine-collections-decorator/cookbook/lazy-chained-matching",id:"doctrine-collections-decorator/cookbook/lazy-chained-matching",title:"Lazy Chained Matching",description:"If you call matching() on a Collection it will be processed immediately and",source:"@site/docs/doctrine-collections-decorator/cookbook/16-lazy-chained-matching.md",sourceDirName:"doctrine-collections-decorator/cookbook",slug:"/doctrine-collections-decorator/cookbook/lazy-chained-matching",permalink:"/doctrine-collections-decorator/cookbook/lazy-chained-matching",draft:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/doctrine-collections-decorator/cookbook/16-lazy-chained-matching.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{title:"Lazy Chained Matching"},sidebar:"docs",previous:{title:"Loading Prevention in Extra Lazy Collections",permalink:"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention"},next:{title:"rekalogika/domain-event",permalink:"/domain-event/"}},c={},s=[{value:"The Decorator Class",id:"the-decorator-class",level:2},{value:"Usage Example in Entities",id:"usage-example-in-entities",level:2},{value:"The Caller Side",id:"the-caller-side",level:2}],d={toc:s},p="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"If you call ",(0,a.kt)("inlineCode",{parentName:"p"},"matching()")," on a ",(0,a.kt)("inlineCode",{parentName:"p"},"Collection")," it will be processed immediately and\nit will return you the result. Except when you use ",(0,a.kt)("inlineCode",{parentName:"p"},"EXTRA_LAZY")," fetch mode, then\nit will return a ",(0,a.kt)("inlineCode",{parentName:"p"},"LazyCriteriaCollection"),". But any subsequent ",(0,a.kt)("inlineCode",{parentName:"p"},"matching()")," call\non the result will still be processed immediately."),(0,a.kt)("p",null,"We can decorate the collection so that chained-",(0,a.kt)("inlineCode",{parentName:"p"},"matching()")," will be done lazily,\nand all the criteria in the chain of ",(0,a.kt)("inlineCode",{parentName:"p"},"matching()")," will be merged. The actual\n",(0,a.kt)("inlineCode",{parentName:"p"},"matching()")," query will be delayed until the caller calls a method that requires\nthe result."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"/** @var Collection<array-key,mixed> $collection */\n\n$result = $collection->matching()->matching()->matching();\n\nforeach ($result as $item) {\n    // ...\n} \n")),(0,a.kt)("p",null,"With the standard behavior, the above code will do the processing three times\n(twice with ",(0,a.kt)("inlineCode",{parentName:"p"},"EXTRA_LAZY"),"). With our decorator, it will only be done once when\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"foreach")," is called."),(0,a.kt)("h2",{id:"the-decorator-class"},"The Decorator Class"),(0,a.kt)("p",null,"This package already comes with ",(0,a.kt)("inlineCode",{parentName:"p"},"LazyMatchingCollection")," that you can use for\nthis purpose."),(0,a.kt)("h2",{id:"usage-example-in-entities"},"Usage Example in Entities"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"use Doctrine\\Common\\Collections\\Collection;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Rekalogika\\Collections\\Decorator\\LazyMatching\\LazyMatchingCollection;\n\n#[ORM\\Entity()]\nclass BookShelf\n{\n    #[ORM\\OneToMany(targetEntity: Book::class, fetch: 'EXTRA_LAZY', indexBy: 'id')]\n    private Collection $books;\n\n    public function __construct()\n    {\n        $this->books = new ArrayCollection();\n    }\n\n    /**\n     * @return Collection<array-key,Book>&Selectable<array-key,Book>\n     */\n    public function getBooks(): Collection&Selectable\n    {\n        return new LazyMatchingCollection($this->books);\n    }\n\n    public function getScienceBook(): Collection\n    {\n        return $this->getBooks()->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->eq('genre', 'science'))\n        );\n    }\n\n    public function getOldScienceBook(): Collection\n    {\n        return $this->getScienceBook()->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->lt('publishedAt', new \\DateTime('-10 years')))\n        );\n    }\n}\n")),(0,a.kt)("h2",{id:"the-caller-side"},"The Caller Side"),(0,a.kt)("p",null,"Then the caller will be able to do something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"$bookShelf = $entityManager->find(BookShelf::class, 1);\n\n$oldScienceBook = $bookShelf->getOldScienceBook();\n\nforeach ($oldScienceBook as $book) {\n    echo $book->getTitle();\n}\n")),(0,a.kt)("p",null,"Nothing will be loaded from the database until the ",(0,a.kt)("inlineCode",{parentName:"p"},"foreach"),". We can also safely\nuse the result in something like ",(0,a.kt)("inlineCode",{parentName:"p"},"PagerFanta"),"."))}h.isMDXComponent=!0}}]);