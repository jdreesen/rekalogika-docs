"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[522],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),p=c(t),d=i,h=p["".concat(l,".").concat(d)]||p[d]||m[d]||o;return t?a.createElement(h,s(s({ref:n},u),{},{components:t})):a.createElement(h,s({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,s=new Array(o);s[0]=d;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[p]="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9677:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=t(7462),i=(t(7294),t(3905));const o={title:"Basic Usage"},s=void 0,r={unversionedId:"domain-event/basic-usage",id:"domain-event/basic-usage",title:"Basic Usage",description:"Creating Domain Events",source:"@site/docs/domain-event/01-basic-usage.md",sourceDirName:"domain-event",slug:"/domain-event/basic-usage",permalink:"/domain-event/basic-usage",draft:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/docs/domain-event/01-basic-usage.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Basic Usage"},sidebar:"docs",previous:{title:"Introduction & Installation",permalink:"/domain-event/intro"},next:{title:"Miscellaneous",permalink:"/domain-event/misc"}},l={},c=[{value:"Creating Domain Events",id:"creating-domain-events",level:2},{value:"Recording Events",id:"recording-events",level:2},{value:"Listening to Events",id:"listening-to-events",level:2},{value:"Equatable Domain Events",id:"equatable-domain-events",level:2},{value:"Manual Control",id:"manual-control",level:2},{value:"Domain-Event-Aware Entity Manager",id:"domain-event-aware-entity-manager",level:3},{value:"Manual Dispatching",id:"manual-dispatching",level:3},{value:"Clearing Events",id:"clearing-events",level:3},{value:"Immediate Dispatcher Installation",id:"immediate-dispatcher-installation",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Caveats",id:"caveats",level:2}],u={toc:c},p="wrapper";function m(e){let{components:n,...t}=e;return(0,i.kt)(p,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"creating-domain-events"},"Creating Domain Events"),(0,i.kt)("p",null,"Domain events are plain old PHP objects that you create to represent a specific\nevent happening in your domain."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// our event superclass for the Post object\n\nabstract class AbstractPostEvent\n{\n    public function __construct(private string $id)\n    {\n    }\n\n    public function getId(): string\n    {\n        return $this->id;\n    }\n}\n\n// our concrete events\n\nfinal class PostCreated extends AbstractPostEvent\n{\n}\n\nfinal class PostChanged extends AbstractPostEvent\n{\n}\n\nfinal class PostRemoved extends AbstractPostEvent\n{\n}\n")),(0,i.kt)("h2",{id:"recording-events"},"Recording Events"),(0,i.kt)("p",null,"Your emitters (entities) must implement ",(0,i.kt)("inlineCode",{parentName:"p"},"DomainEventEmitterInterface"),".\nThere is a ",(0,i.kt)("inlineCode",{parentName:"p"},"DomainEventEmitterTrait")," to help you with that. To record events,\nyou can use the method ",(0,i.kt)("inlineCode",{parentName:"p"},"recordEvents()")," defined in the trait."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Doctrine\\Common\\Collections\\ArrayCollection;\nuse Doctrine\\Common\\Collections\\Collection;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait;\nuse Symfony\\Component\\Uid\\UuidV7;\n\nclass Post implements DomainEventEmitterInterface\n{\n    use DomainEventEmitterTrait;\n\n    private string $id;\n    private string $title;\n    /** @var Collection<int,Comment> */\n    private Collection $comments;\n\n    public function __construct(string $title)\n    {\n        $this->id = new UuidV7();\n        $this->title = $title;\n        $this->comments = new ArrayCollection();\n\n        // highlight-next-line\n        $this->recordEvent(new PostCreated($this->id));\n    }\n\n    // __remove() is our special method that gets triggered when the entity is\n    // going to be removed from the persistence layer\n    public function __remove()\n    {\n        // highlight-next-line\n        $this->recordEvent(new PostRemoved($this->id));\n    }\n\n    public function setTitle(string $title): void\n    {\n        $this->title = $title;\n\n        // highlight-next-line\n        $this->recordEvent(new PostChanged($this->id));\n    }\n}\n")),(0,i.kt)("h2",{id:"listening-to-events"},"Listening to Events"),(0,i.kt)("p",null,"To listen to the events, you can use the usual Symfony way of listening to\nevents. The framework will collect events from persisted entities, and dispatch\nthem at the end of the ",(0,i.kt)("inlineCode",{parentName:"p"},"flush()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener;\n\n#[AsEventListener]\nclass PostEventListener\n{\n    // this method will be invoked after a new Post is persist()-ed & flush()-ed\n    public function __invoke(PostCreated $event) {\n        $postId = $event->getId();\n        // ...\n    }\n}\n")),(0,i.kt)("p",null,"Alternatively, you can use different attributes to choose a different\ndispatching strategy."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsImmediateDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPostFlushDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPreFlushDomainEventListener;\n\nclass PostEventListener\n{\n    #[AsImmediateDomainEventListener]\n    public function immediate(PostCreated $event) {\n        // this will run immediately after the entity records the event\n    }\n\n    #[AsPreFlushDomainEventListener]\n    public function preFlush(PostCreated $event) {\n        // this will run when you flush() the new post. before the actual\n        // flush()\n    }\n\n    #[AsPostFlushDomainEventListener]\n    public function postFlush(PostCreated $event) {\n        // this will run when you flush() the new post. after the actual\n        // flush()\n    }\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AsEventListener")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"AsPostFlushDomainEventListener")," currently have\nidentical behavior, but they utilize different event dispatchers. We plan to\nhave a different event dispatcher behavior with\n",(0,i.kt)("inlineCode",{parentName:"li"},"AsPostFlushDomainEventListener")," while keeping ",(0,i.kt)("inlineCode",{parentName:"li"},"AsEventListener")," standard."),(0,i.kt)("li",{parentName:"ul"},"Doing a ",(0,i.kt)("inlineCode",{parentName:"li"},"flush()")," inside a pre-flush listener is not allowed and will result\nin a ",(0,i.kt)("inlineCode",{parentName:"li"},"FlushNotAllowedException"),"."))),(0,i.kt)("h2",{id:"equatable-domain-events"},"Equatable Domain Events"),(0,i.kt)("p",null,"A domain event can optionally implement ",(0,i.kt)("inlineCode",{parentName:"p"},"EquatableDomainEventInterface")," which\nrequires the method ",(0,i.kt)("inlineCode",{parentName:"p"},"getSignature()"),". Two objects with the same signature will\nbe considered identical by ",(0,i.kt)("inlineCode",{parentName:"p"},"DomainEventManager")," and won't be dispatched twice."),(0,i.kt)("p",null,"This is useful if your entity is working with a million of related objects. By\nimplementing ",(0,i.kt)("inlineCode",{parentName:"p"},"EquatableDomainEventInterface"),", you can have your ",(0,i.kt)("inlineCode",{parentName:"p"},"ObjectChanged"),"\nevent dispatched only once, and occupies only a single spot in the memory,\ninstead of a million times."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Rekalogika\\Contracts\\DomainEvent\\EquatableDomainEventInterface;\n\nclass PostCommentAdded implements EquatableDomainEventInterface\n{\n    public function __construct(private string $postId)\n    {\n    }\n\n    public function getSignature(): string\n    {\n        return sha1(serialize($this));\n    }\n}\n\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait;\n\nclass Post implements DomainEventEmitterInterface\n{\n    use DomainEventEmitterTrait;\n\n    // ...\n\n    public function addComment(string $comment): Comment\n    {\n        // ...\n\n        // the PostCommentAdded event will only get dispatched once despite of\n        // addComment being called multiple times.\n        $this->recordEvent(new PostCommentAdded($this->id));\n    }\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Equatable domain events only applies to pre-flush and post-flush events.\nImmediate domain events are dispatched immediately, and there is no chance for\nthe equatable check to take place.")),(0,i.kt)("h2",{id:"manual-control"},"Manual Control"),(0,i.kt)("h3",{id:"domain-event-aware-entity-manager"},"Domain-Event-Aware Entity Manager"),(0,i.kt)("p",null,"To manually manage domain events, you can use\n",(0,i.kt)("inlineCode",{parentName:"p"},"DomainEventAwareEntityManagerInterface")," in place of the regular\n",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManagerInterface"),". It adds several methods to the Entity Manager that you\ncan use to manage domain event dispatching."),(0,i.kt)("h3",{id:"manual-dispatching"},"Manual Dispatching"),(0,i.kt)("p",null,"You can disable automatic dispatching on ",(0,i.kt)("inlineCode",{parentName:"p"},"flush()")," by calling\n",(0,i.kt)("inlineCode",{parentName:"p"},"setAutoDispatchDomainEvents(false)"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"/** @var DomainEventAwareEntityManagerInterface $entityManager */\n\n$entityManager->setAutoDispatchDomainEvents(false);\n\n// ...\n\n$entityManager->dispatchPreFlushDomainEvents();\n$entityManager->flush();\n$entityManager->dispatchPostFlushDomainEvents();\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Immediate dispatching is dispatched outside ",(0,i.kt)("inlineCode",{parentName:"p"},"DomainEventManager")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"DomainEventAwareEntityManager"),", and therefore unaffected by\n",(0,i.kt)("inlineCode",{parentName:"p"},"setAutoDispatchDomainEvents()"),".")),(0,i.kt)("h3",{id:"clearing-events"},"Clearing Events"),(0,i.kt)("p",null,"If the domain event queues are not empty at the end of the request,\n",(0,i.kt)("inlineCode",{parentName:"p"},"DomainEventManager")," will throw ",(0,i.kt)("inlineCode",{parentName:"p"},"UndispatchedEventsException"),". To prevent that\nfrom happening, if you disable auto-dispatch, you need to make sure that you\ndispatch both pre-flush and post-flush events as above. Alternatively, you can\nclear the events if you don't want them dispatched:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"/** @var DomainEventAwareEntityManagerInterface $entityManager */\n\n$entityManager->setAutoDispatchDomainEvents(false);\n\n// ...\n\n$entityManager->flush();\n$entityManager->clearDomainEvents();\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In the event of an uncaught error, the framework will automatically\nclear undispatched events using the ",(0,i.kt)("inlineCode",{parentName:"p"},"kernel.exception")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"console.error"),"\nevents, so in such cases, you don't have to handle that manually. But if you\ncatch an exception that previously caused pending events not to be dispatched,\nyou need to manually clear the events.")),(0,i.kt)("h2",{id:"immediate-dispatcher-installation"},"Immediate Dispatcher Installation"),(0,i.kt)("p",null,"Immediate event dispatcher works by installing the event dispatcher to a static\nvariable. This installation happens on several opportunities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In these events: ",(0,i.kt)("inlineCode",{parentName:"li"},"kernel.request")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"console.command"),"."),(0,i.kt)("li",{parentName:"ul"},"During the initialization of ",(0,i.kt)("inlineCode",{parentName:"li"},"ManagerRegistry"),"."),(0,i.kt)("li",{parentName:"ul"},"During the initialization of an ",(0,i.kt)("inlineCode",{parentName:"li"},"EntityManagerInterface"),".")),(0,i.kt)("p",null,"When any of these don't occur, there is no opportunity to install the event\ndispatcher. This usually happens only in isolated unit tests. To fix the\nproblem, you can install a stub event dispatcher manually like the following."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use PHPUnit\\Framework\\TestCase;\nuse Rekalogika\\DomainEvent\\ImmediateDomainEventDispatcherInstaller;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\n\nclass SomeTest extends TestCase\n{\n    public function setUp(): void\n    {\n        $installer = new ImmediateDomainEventDispatcherInstaller(new EventDispatcher);\n        $installer->install();\n\n    }\n\n    // ...\n}\n")),(0,i.kt)("p",null,"In integration tests where you have access to the service container, but the\ntests don't involve ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ManagerRegistry"),", you can pull the\ninstaller from the container to install the immediate dispatcher:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"use Rekalogika\\DomainEvent\\ImmediateDomainEventDispatcherInstaller;\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\n\nclass SomeTest extends KernelTestCase\n{\n    public function setUp(): void\n    {\n        self::bootKernel();\n        static::getContainer()\n          ->get(ImmediateDomainEventDispatcherInstaller::class)->install();\n    }\n\n    // ...\n}\n")),(0,i.kt)("h2",{id:"best-practices"},"Best Practices"),(0,i.kt)("p",null,"This explains our best practices that others might find useful, but not strictly\nrequired."),(0,i.kt)("p",null,"Use UUIDs as identifiers & have the entities generate one for themselves on\ninstantiation. That means new entities already have an ID before ",(0,i.kt)("inlineCode",{parentName:"p"},"flush()")," and\nyou can store just the ID in our domain event objects, not the entire object. It\nwill make the event usable in all cases. It will also result in better logistics\nas you can easily pass the events anywhere without alteration."),(0,i.kt)("p",null,"Use pre-flush events to make alterations to your domain that will be\n",(0,i.kt)("inlineCode",{parentName:"p"},"flush()"),"-ed together along with the other changes."),(0,i.kt)("p",null,"Use post-flush for things that should occur only if the change is successful,\nlike notifications, etc."),(0,i.kt)("h2",{id:"caveats"},"Caveats"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Currently only supports ",(0,i.kt)("inlineCode",{parentName:"li"},"EntityManager"),". Support for other ",(0,i.kt)("inlineCode",{parentName:"li"},"ObjectManager"),"s\nis planned."),(0,i.kt)("li",{parentName:"ul"},"It is not aware of explicit transactions yet. You should dispatch the events\nmanually if you are using an explicit transaction as described above. In the\nfuture, we have plans to dispatch post-flush events after the outermost\n",(0,i.kt)("inlineCode",{parentName:"li"},"commit()"),", and dispatch pre-flush events before every ",(0,i.kt)("inlineCode",{parentName:"li"},"commit()"),"."),(0,i.kt)("li",{parentName:"ul"},"It is an inconvenience that Symfony Event Dispatcher does not currently\nsupport event inheritance. We cannot have a single listener for an entire\nclass of domain events, and for example, use it to implement the outbox\npattern. We plan to fix this in the future.")))}m.isMDXComponent=!0}}]);