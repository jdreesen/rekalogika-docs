"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[5042],{3119:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=a(5893),n=a(1151);const o={title:"Rationale, or Why Create Another Mapper?"},i=void 0,s={id:"mapper/rationale",title:"Rationale, or Why Create Another Mapper?",description:"We developed a project that during its planning phase we determined that it",source:"@site/docs/mapper/22-rationale.md",sourceDirName:"mapper",slug:"/mapper/rationale",permalink:"/mapper/rationale",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/22-rationale.md",tags:[],version:"current",sidebarPosition:22,frontMatter:{title:"Rationale, or Why Create Another Mapper?"},sidebar:"docs",previous:{title:"Debugging the Mapper",permalink:"/mapper/debugging"},next:{title:"rekalogika/psr-16-simple-cache-bundle",permalink:"/psr-16-simple-cache-bundle/"}},p={},l=[];function d(e){const t={a:"a",code:"code",p:"p",...(0,n.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"We developed a project that during its planning phase we determined that it\nwould be beneficial to integrate an automapper into the architecture. We looked\naround and found some potential automappers, and decided to go ahead with the\nplanned architecture."}),"\n",(0,r.jsxs)(t.p,{children:["We first tried\n",(0,r.jsx)(t.a,{href:"https://github.com/mark-gerarts/automapper-plus",children:"AutoMapper-Plus"})," and\nimmediately ran into the issue that it reads and writes directly to properties,\nincluding private properties, which is unacceptable to our purposes. For\nexample, we store monetary values as integers in the object, and convert them\nfrom and to ",(0,r.jsx)(t.code,{children:"Money"})," objects in the getter and setter. Using this mapper it would\nget the raw integers, not the ",(0,r.jsx)(t.code,{children:"Money"})," objects. We also feel it violates the\nprinciples of encapsulation. However, this was not a blocker as it supports a\ncustom property accessor, so we resolved this issue by creating an adapter that\nuses Symfony PropertyAccess component."]}),"\n",(0,r.jsx)(t.p,{children:"With AutoMapper-Plus, users are expected to create a mapping configuration for\neach mapping pair. It has an automatic creation of mappings, but it seems to\nonly work for simple mapping. Also, all of my entities and DTOs are typed, but I\nneed to create a mapping for every non-trivial pair, despite the type\ninformation is there in the involved classes. Custom mapper is available, but it\ndoes not give me the main mapper, so if a mapping pair uses a custom mapper, I'm\nresponsible for mapping everything, including the nested objects myself, because\nthe option to delegate to the main mapper is not available. There was another\ncase that was simply not possible to accomplish, I don't remember what it was,\nbut it forced us to switch to another mapper overnight."}),"\n",(0,r.jsxs)(t.p,{children:["Our next mapper was ",(0,r.jsx)(t.a,{href:"https://github.com/jolicode/automapper",children:"Jolicode\nAutomapper"}),", formerly known as ",(0,r.jsx)(t.a,{href:"https://github.com/janephp/automapper",children:"Jane\nAutomapper"}),". It behaved as expected,\nthere were no big surprises, and there was very little to complain about its\nbehavior. It should also be very fast, as it compiles its mapping code to PHP\nfiles. The problem was error handling. When an error occurred in the compiled\nmappers, it was usually a ",(0,r.jsx)(t.code,{children:"TypeError"}),". It was difficult to debug, and even more\ndifficult to resolve the problem, addressing the problem requires the skill of\nworking with AST. However, we found that the problems were deployment errors\n(usually forgetting to clear the cache), some edge cases (easy to work around),\nor bugs in the mapper. We did contributed some fixes back to the project."]}),"\n",(0,r.jsx)(t.p,{children:"The second problem was that the mapper was difficult to extend. Adding a new\ntransformer requires the skill of working with AST, and there was no option to\ndo a mapping using plain old PHP code that you write yourself. Our team was not\nhappy with this fact. We hit a brick wall when a new requirement surfaced that\nrequires the mapper to target an abstract class, a feature that was not\nsupported by the mapper. We figured it would be easier for us to spend a week\ncreating our own mapper from scratch using our experiences with the other\nmappers, and here we are."}),"\n",(0,r.jsx)(t.p,{children:"Other mappers that were considered:"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://github.com/SymfonyCasts/micro-mapper/",children:"MicroMapper"})," is a mapper that\nrequires you to write the mapping code yourself. It is all manual work, but\nstill working under the mapping framwork, and should be suitable for our\npurpose, as long as we are willing to write the mapping code ourselves. The\nmapping code also supports delegating to the main mapper, unlike\nAutoMapper-Plus. However, we were way past of contemplating whether to do it\nmanually, so we did not consider it further."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://github.com/symfony/symfony/pull/51741",children:"Pull request for a future Symfony Mapper"}),".\nIn the form that I saw it, it was too simplistic, and does not provide any\nextension points. I (@priyadi) did provide some feedback in the pull request."]})]})}function c(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,t,a)=>{a.d(t,{Z:()=>s,a:()=>i});var r=a(7294);const n={},o=r.createContext(n);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);